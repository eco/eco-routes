import {
  encodeFunctionData,
  Hex,
  encodeDeployData,
  keccak256,
  toHex,
  concat,
  decodeDeployData,
} from 'viem'
import fs from 'fs'
import path from 'path'

// CREATEX Deployer ABI for the deploy function
const CREATE_X_ABI = [
  {
    inputs: [
      { name: 'salt', type: 'bytes32' },
      { name: 'initCode', type: 'bytes' },
    ],
    name: 'deployCreate2',
    outputs: [{ name: 'newContract', type: 'address' }],
    stateMutability: 'payable',
    type: 'function',
  },
]

type Contract = {
  name: 'IntentSource' | 'Inbox' | 'HyperProver'
  args: any[]
}
// Address of the CREATEXDeployer contract
const CREATE_X_DEPLOYER_ADDRESS = '0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed'

// List of contracts to deploy
const CONTRACTS_TO_DEPLOY: Contract[] = [
  { name: 'IntentSource', args: [] },
  { name: 'Inbox', args: [] },
  { name: 'HyperProver', args: [] },
]

/**
 * Generates the bytecode and deployment data for a contract
 * @param contractName The name of the contract to deploy (matches the JSON file name)
 * @param salt The salt to use for the CREATE2 deployment (32 bytes hex string with 0x prefix)
 * @param chainId The chain ID to deploy to
 * @returns Object with contract deployment data
 */
export function generateBytecodeDeployData(create2Params: {
  value: bigint
  salt: Hex
  contract: Contract
}): {
  contractName: string
  salt: Hex
  initCodeHash: Hex
  args: any[]
  deployBytecode: Hex
} {
  const { value, salt, contract } = create2Params
  const contractName = contract.name
  // Path to the compiled contract JSON
  const contractJsonPath = path.join(
    process.cwd(),
    'out',
    `${contractName}.sol`,
    `${contractName}.json`,
  )

  if (!fs.existsSync(contractJsonPath)) {
    throw new Error(`Contract JSON file not found: ${contractJsonPath}`)
  }

  // Read the contract JSON file
  const contractJson = JSON.parse(fs.readFileSync(contractJsonPath, 'utf8'))

  // Extract bytecode from the JSON
  const bytecode = contractJson.bytecode.object as Hex

  if (!bytecode || bytecode === '0x') {
    throw new Error(`Bytecode is empty for ${contractName}`)
  }

  // // Generate the unique salt for the contract
  // // The unique salt is generated by hashing the provided salt and the contract name
  // const uniqueSalt = keccak256(concat([salt, toHex(contractName)]))
  // console.log(`Unique salt for ${contractName}: ${uniqueSalt}`)

  // Encode the deployment data
  // The deployment data includes the bytecode and constructor arguments
  const deploymentBytecode = encodeDeployData({
    abi: contractJson.abi,
    bytecode,
    args: contract.args,
  })

  // Encode the function call to deploy
  const deployBytecode = encodeFunctionData({
    abi: CREATE_X_ABI,
    functionName: 'deployCreate2',
    args: [salt, deploymentBytecode],
  })

  return {
    contractName,
    salt,
    initCodeHash: keccak256(deploymentBytecode),
    args: contract.args,
    deployBytecode,
  }
}

/**
 * Generates deployment data for multiple contracts using the same salt
 * @param salt The salt to use for all deployments (32 bytes hex string with 0x prefix)
 * @returns Object with deployment data for all contracts
 */
export function generateMultipleDeploymentData(salt: Hex): Record<string, any> {
  const deploymentData: Record<string, any> = {
    createXDeployerAddress: CREATE_X_DEPLOYER_ADDRESS,
    salt,
    contracts: {},
  }

  for (const contract of CONTRACTS_TO_DEPLOY) {
    const contractName = contract.name
    try {
      console.log(`Generating deployment data for ${contractName}...`)
      const contractData = generateBytecodeDeployData({
        value: 0n,
        salt,
        contract,
      })

      deploymentData.contracts[contractName] = {
        args: contractData.args,
        initCodeHash: contractData.initCodeHash,
        deployBytecode: contractData.deployBytecode,
      }

      console.log(`Successfully generated deployment data for ${contractName}`)
    } catch (error) {
      console.error(
        `Error generating deployment data for ${contractName}:`,
        error,
      )
    }
  }

  return deploymentData
}

/**
 * Saves deployment data to a JSON file
 * @param deploymentData The deployment data to save
 * @param outputPath The path to save the JSON file to
 */
export function saveDeploymentData(
  deploymentData: Record<string, any>,
  outputPath: string = 'bytecode_deployment.json',
): void {
  fs.writeFileSync(outputPath, JSON.stringify(deploymentData, null, 2))
  console.log(`Deployment data saved to ${outputPath}`)
}

/**
 * Generates deployment data for all contracts and saves to JSON
 * @param salt The salt to use for all deployments
 * @param chainId The chain ID for the deployments
 * @param outputPath The path to save the JSON file to
 */
export function generateDeploymentFile(
  salts: { value: Hex; name: string }[],
  outputPath: string = 'bytecode_deployment.json',
): void {
  console.log(`Generating deployment data with salts ${salts.length}`)
  const deploymentData: Record<string, any> = {}
  for (const salt of salts) {
    console.log(`Generating deployment data for salt ${salt}...`)
    deploymentData[salt.name] = generateMultipleDeploymentData(salt.value)
  }
  saveDeploymentData(deploymentData, outputPath)
  console.log('Deployment data generation complete')
}

// async function main() {
//   generateDeploymentFile([{ name: 'test', value: '0x4dad9ff70cc0946e063bbeb57f1ded0f808a3026d96866d52157e150b507a986' }], 'bytecode_deployment.json')
// }

// main().catch((err) => {
//   console.error('Error:', err)
// })
